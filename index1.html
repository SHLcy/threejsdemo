<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - GLTFloader</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        html, body {
            margin: 0;
            padding: 0;
        }
    </style>
</head>

<body>

<script type="module">

    import * as THREE from '../build/three.module.js';
    import { OrbitControls } from './jsm/controls/OrbitControls.js';
    import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
    import { RGBELoader } from './jsm/loaders/RGBELoader.js';
    import { RoughnessMipmapper } from './jsm/utils/RoughnessMipmapper.js';
    let camera, scene, renderer, raycaster;
    let mouse = {}

    init();
    render();

    function init() {
        const container = document.createElement( 'div' );
        document.body.appendChild( container );
        camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight,1, 1000 );
        camera.position.set(40, 100, 0);
        scene = new THREE.Scene();
        new RGBELoader()
            .setPath( 'textures/equirectangular/' )
            .load( 'venice_sunset_1k.hdr', function ( texture ) {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.environment = texture;
                render();
                const roughnessMipmapper = new RoughnessMipmapper( renderer );
                const loader = new GLTFLoader()
                loader.load( '病房.gltf', function ( gltf ) {
                    gltf.scene.position.x = 10;
                    gltf.scene.position.z = 20;

                    gltf.scene.scale.set(4, 4, 4)
                    gltf.scene.traverse( function ( child ) {
                        if ( child.isMesh ) {
                            roughnessMipmapper.generateMipmaps( child.material );
                        }
                    } );
                    scene.add( gltf.scene );
                    roughnessMipmapper.dispose();
                    render();
                } );
            } );
        // new RGBELoader()
        //     .setPath( 'textures/equirectangular/' )
        //     .load( 'venice_sunset_1k.hdr', function ( texture ) {
        //         texture.mapping = THREE.EquirectangularReflectionMapping;
        //         scene.environment = texture;
        //         render();
        //         const roughnessMipmapper = new RoughnessMipmapper( renderer );
        //         const loader = new GLTFLoader()
        //         loader.load( '医院模型99.gltf', function ( gltf ) {
        //             gltf.scene.position.x = 0;
        //             gltf.scene.position.z = 30;
        //             gltf.scene.position.y = 30;
        //             gltf.scene.scale.set(1, 1, 1)
        //             gltf.scene.traverse( function ( child ) {
        //                 if ( child.isMesh ) {
        //                     roughnessMipmapper.generateMipmaps( child.material );
        //                 }
        //             } );
        //             scene.add( gltf.scene );
        //             roughnessMipmapper.dispose();
        //             render();
        //         } );
        //     } );
        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1;
        renderer.outputEncoding = THREE.sRGBEncoding;
        container.appendChild( renderer.domElement );
        const controls = new OrbitControls( camera, renderer.domElement );
        controls.addEventListener( 'change', render ); // use if there is no animation loop
        controls.minDistance = 2;
        controls.maxDistance = 100;
        controls.target.set( 0, 0, - 0.2 );
        controls.update();
        window.addEventListener( 'resize', onWindowResize );
        window.addEventListener( 'click', onMouseClick, false );
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
        render();
    }
    function onMouseClick(event) {
        event.preventDefault();
        raycaster = new THREE.Raycaster()
        mouse = new THREE.Vector2()
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        //console.log("x: " + mouse.x + ", y: " + mouse.y);
        raycaster.setFromCamera(mouse, camera)
        var intersects = raycaster.intersectObjects(scene.children.filter(item => item.type === 'Group')[0].children[0].children);
        if (intersects.length > 0) {

            if (intersects[0].object.name === "3DGeom~45_Defintion_1") {
                const rectLight3 = new THREE.RectAreaLight( 0xffffff, 1, 18, 25);
                // rectLight3.position.set( 10,0,0 );
                rectLight3.position.set( 28 , 1, 10 );
                rectLight3.lookAt( 0, -800, 10 );

                scene.add( rectLight3 );
                const rectLightMesh = new THREE.Mesh( new THREE.PlaneBufferGeometry(), new THREE.MeshBasicMaterial( {color:'#ffffff', side: THREE.BackSide } ) );
                rectLightMesh.scale.x = rectLight3.width;
                rectLightMesh.scale.y = rectLight3.height;
                rectLight3.add( rectLightMesh );
                render()
                setTimeout(() => {
                    scene.remove(rectLight3)
                    render()
                }, 1000)
            }
            if (intersects[0].object.name === "3DGeom~45_Defintion") {
                const rectLight3 = new THREE.RectAreaLight( 0xffffff, 1, 14, 25);
                rectLight3.position.set( 25 ,1, -7 );
                rectLight3.lookAt( 0, -900, -7 );

                scene.add( rectLight3 );
                const rectLightMesh = new THREE.Mesh( new THREE.PlaneBufferGeometry(), new THREE.MeshBasicMaterial( {color:'#fff', side: THREE.BackSide } ) );
                rectLightMesh.scale.x = rectLight3.width;
                rectLightMesh.scale.y = rectLight3.height;
                rectLight3.add( rectLightMesh );
                render()
                setTimeout(() => {
                    scene.remove(rectLight3)
                    render()
                }, 1000)
            }
            if (intersects[0].object.name === "mesh_333") {
                const rectLight3 = new THREE.RectAreaLight( 0xffffff, 4, 18, 12);
                rectLight3.position.set( 20 ,1, -30 );
                rectLight3.lookAt( 0, -800, -30 );

                scene.add( rectLight3 );
                const rectLightMesh = new THREE.Mesh( new THREE.PlaneBufferGeometry(), new THREE.MeshBasicMaterial( {color:'#fff', side: THREE.BackSide } ) );
                rectLightMesh.scale.x = rectLight3.width;
                rectLightMesh.scale.y = rectLight3.height;
                rectLight3.add( rectLightMesh );
                render()
                setTimeout(() => {
                    scene.remove(rectLight3)
                    render()
                }, 1000)
            }

            // if ()
            // const color = intersects[0].object.material.color
            // intersects[0].object.material.color =  new THREE.Color(0xff3333);
            console.log(intersects[0]);
            // intersects[0].object.position.y  = 5
            // setTimeout(() => {
            //     intersects[0].object.material.color = color
            //     render()
            // }, 2000)

            render()
        } else {
            console.log("not touched");
        }
    }
    function render() {
        renderer.render( scene, camera );
    }

</script>

</body>
</html>
